---
layout: bootstrap
title: Running Cucumber
---
# {{page.title}}

There are quite a few ways you can run Cucumber. It depends on what programming language you are using and also what build tool
you are using (if any).

* Command Line
* Rake
* Maven
* Ant
* JUnit
* IDEs (Eclipse, IDEA)
 
## Running Cucumber-JVM
### Command Line
TODO

### JUnit
Create one empty class with the `@RunWith(Cucumber.class)` annotation. 
Executing this class as any JUnit test class will run all features found on the classpath in the same package as this class.
The options to be used are defined with the `@CucumberOptions` (`@Cucumber.Options` is deprecated from version 1.1.5).
{% highlight java %}
package somepackage;

import cucumber.api.CucumberOptions;
import cucumber.api.junit.Cucumber;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(format = "pretty")
public class RunCukesTest {
}
{% endhighlight %}
### TestNG
TODO

### Android
TODO

#### Android options
TODO

### Maven

For Running Cucumber Tests with Maven, you can follow the steps below

Pre-Requisites
*  Maven is installed and added in environment variable (MAVEN_HOME).
   you can verify your maven installation by invoking a terminal/command-line and typing `mvn --version`
*  An IDE (preferably eclipse) configured with latest maven installation and m2eclipse plugin. **(optional)**
*  Additionally cucumber-eclipse plugin can also be installed into eclipse IDE. **(optional)**

Steps
*  Create a simple maven project or fork from cucumber-java examples on github.
*  The pom.xml file - Add the following dependencies ( required if you are creating maven project from scratch)
	```xml
    <dependency>
			<groupId>info.cukes</groupId>
			<artifactId>cucumber-testng</artifactId>
			<version>1.2.2</version>
	</dependency>
    
    <dependency>
			<groupId>info.cukes</groupId>
			<artifactId>cucumber-core</artifactId>
			<version>1.2.2</version>
	</dependency>
	
    <dependency>
			<groupId>info.cukes</groupId>
			<artifactId>cucumber-html</artifactId>
			<version>0.2.3</version>
	</dependency>
	
    <dependency>
			<groupId>info.cukes</groupId>
			<artifactId>cucumber-java</artifactId>
			<version>1.2.2</version>
	</dependency>
	
    <dependency>
			<groupId>info.cukes</groupId>
			<artifactId>cucumber-jvm-deps</artifactId>
			<version>1.0.3</version>
	</dependency>
	
    <dependency>
			<groupId>info.cukes</groupId>
			<artifactId>cucumber-picocontainer</artifactId>
			<version>1.2.2</version>
	</dependency>
<!-- versions change on every cucumber release. please update from maven repository http://mvnrepository.com-->
    ```
*  Add your feature `.feature` files and associated step mapping classes `.java` in `src/test/resources` and `src/test/java` folders respectively.
*  Run the following maven command by navigating to project directory ( directory path where your pom file is located).
	```
    >mvn clean install -DCucumberOptions="--glue package_name_of_step_definitions --format pretty path\to\your\featurefiles"
 ```
 
### Ant
TODO

### Gradle
TODO

## Options

    -g, --glue PATH                        Where glue code (step definitions and hooks) is loaded from.
    -f, --format FORMAT[:PATH_OR_URL]      How to format results. Goes to STDOUT unless PATH_OR_URL is specified.
                                           Built-in FORMAT types: junit, html, pretty, progress, json,usage,rerun. 
										   FORMAT can also be a fully qualified class name.
    -t, --tags TAG_EXPRESSION              Only run scenarios tagged with tags matching TAG_EXPRESSION.
    -n, --name REGEXP                      Only run scenarios whose names match REGEXP.
    -d, --[no-]-dry-run                    Skip execution of glue code.
    -m, --[no-]-monochrome                 Don't colour terminal output.
    -s, --[no-]-strict                     Treat undefined and pending steps as errors.
        --snippets [underscore|camelcase]  Naming convention for generated snippets. Defaults to underscore.
        --dotcucumber PATH_OR_URL          Where to write out runtime information. PATH_OR_URL can be a file system
                                           path or a URL.
    -v, --version                          Print version.
    -h, --help                             You're looking at it.

 Feature path examples:

     <path>                                 Load the files with the extension ".feature" for the directory <path>
                                            and its sub directories.
     <path>/<name>.feature                  Load the feature file <path>/<name>.feature from the file system.
     classpath:<path>/<name>.feature        Load the feature file <path>/<name>.feature from the classpath.
     <path>/<name>.feature:3:9              Load the scenarios on line 3 and line 9 in thefile
                                            <path>/<name>.feature.
     @<path>/<file>                         Parse <path>/<file> for feature paths generated by the rerun formatter.
